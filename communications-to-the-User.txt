# Translation Wiki — Step-by-Step Implementation Plan

This document lays out the complete sequence of actions to build the translation
wiki from scratch. Each step is concrete and executable. Steps are grouped into
phases; within each phase, steps are ordered by dependency.

================================================================================
## PHASE 1: Project Scaffolding & Infrastructure
================================================================================

### Step 1.1: Initialise the Next.js project

```bash
pnpm create next-app@latest translation-wiki --typescript --tailwind --eslint --app --src-dir
cd translation-wiki
```

This creates a Next.js 15 project with App Router, TypeScript, Tailwind CSS v4,
ESLint, and a src/ directory. pnpm is preferred over npm for better compatibility
with React 19 peer dependencies and Shadcn UI.

### Step 1.2: Install core dependencies

```bash
# Runtime dependencies
pnpm add @trpc/server @trpc/client @trpc/tanstack-react-query @tanstack/react-query \
  zod superjson drizzle-orm postgres next-auth@beta bcryptjs slugify

# Dev dependencies
pnpm add -D drizzle-kit @types/node @types/bcryptjs \
  vitest @vitejs/plugin-react jsdom @testing-library/react \
  @testing-library/dom @testing-library/jest-dom vite-tsconfig-paths \
  prettier prettier-plugin-tailwindcss
```

### Step 1.3: Initialise Shadcn UI

```bash
npx shadcn@latest init
```

Choose: neutral base colour, CSS variables for theming. This creates
components.json and src/lib/utils.ts (cn helper).

Add initial components:
```bash
npx shadcn@latest add button card input label textarea table tabs \
  dialog dropdown-menu avatar badge separator scroll-area tooltip
```

### Step 1.4: Set up local PostgreSQL with Docker

Create docker-compose.yml at root:

```yaml
services:
  db:
    image: postgres:16-alpine
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: translation_wiki
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

Create .env.local:
```
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/translation_wiki
AUTH_SECRET=<generate-with-openssl-rand-base64-32>
AUTH_URL=http://localhost:3000
```

Create .env.example (committed to git, without secrets):
```
DATABASE_URL=postgresql://user:password@host:5432/dbname
AUTH_SECRET=
AUTH_URL=http://localhost:3000
```

Start the database:
```bash
docker compose up -d
```

### Step 1.5: Define the database schema with Drizzle

Create src/server/db/schema.ts with all core tables:

- users (id, email, username, passwordHash, role, createdAt, updatedAt)
- languages (id, code, name, displayName)
- authors (id, name, nameOriginalScript, slug, era, description)
- texts (id, title, titleOriginalScript, slug, languageId, authorId, description, sourceUrl, totalChapters)
- chapters (id, textId, chapterNumber, slug, title, sourceContent [jsonb], ordering)
- translations (id, chapterId, currentVersionId, createdAt, updatedAt)
- translation_versions (id, translationId, versionNumber, content [jsonb], authorId, editSummary, createdAt, previousVersionId)
- endorsements (id, userId, translationVersionId, createdAt) with unique(userId, translationVersionId)

Create src/server/db/index.ts — Drizzle client instantiation using postgres.js driver.

Create drizzle.config.ts at root:
```typescript
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/server/db/schema.ts",
  out: "./drizzle/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});
```

### Step 1.6: Generate and run the initial migration

```bash
pnpm drizzle-kit generate
pnpm drizzle-kit migrate
```

Verify with:
```bash
pnpm drizzle-kit studio
```

### Step 1.7: Configure NextAuth.js v5

Create src/server/auth/config.ts — credentials provider with email/password,
bcrypt password verification, JWT session strategy.

Create src/server/auth/index.ts — NextAuth() call with Drizzle adapter or
manual user lookup in authorize callback.

Create src/app/api/auth/[...nextauth]/route.ts — export { GET, POST } handlers.

Create middleware.ts at src root — protect /edit/* and /api/trpc/* mutation
routes, allow public access to reading routes.

### Step 1.8: Set up tRPC v11

Create src/server/trpc/init.ts — initTRPC with superjson transformer, context
creation (session from NextAuth).

Create src/server/trpc/router.ts — root appRouter merging sub-routers.

Create src/server/trpc/routers/ directory with placeholder files:
- texts.ts (list, getBySlug)
- chapters.ts (getByTextAndNumber)
- translations.ts (getForChapter, create, update)
- endorsements.ts (toggle, count)
- users.ts (profile, register)

Create src/app/api/trpc/[trpc]/route.ts — fetchRequestHandler export.

Create src/trpc/client.tsx — client-side tRPC + React Query provider.
Create src/trpc/server.tsx — server-side caller for RSC.

### Step 1.9: Set up Vitest

Create vitest.config.mts:
```typescript
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [tsconfigPaths(), react()],
  test: {
    environment: "jsdom",
    setupFiles: "./tests/setup.ts",
  },
});
```

Create tests/setup.ts with @testing-library/jest-dom import and cleanup.

Add scripts to package.json:
```json
{
  "test": "vitest",
  "test:run": "vitest run",
  "test:coverage": "vitest run --coverage",
  "typecheck": "tsc --noEmit",
  "db:generate": "drizzle-kit generate",
  "db:migrate": "drizzle-kit migrate",
  "db:push": "drizzle-kit push",
  "db:studio": "drizzle-kit studio",
  "db:seed": "tsx scripts/seed-db.ts",
  "format": "prettier --write ."
}
```

### Step 1.10: Configure .gitignore

Ensure these are ignored:
```
node_modules/
.next/
.env.local
.env*.local
data/raw/
*.tsbuildinfo
```

### Step 1.11: Initialise git repository

```bash
git init
git add .
git commit -m "Initial project scaffolding: Next.js 15, tRPC, Drizzle, NextAuth, Vitest"
```

================================================================================
## PHASE 2: Source Text Acquisition & Seeding
================================================================================

### Step 2.1: Create the ctext.org acquisition script

Create scripts/acquire-ctext.ts:

1. Authenticate with ctext.org (requires a free CTP account)
2. For each chapter 1–140 of URN ctp:zhuzi-yulei:
   a. Call the gettext API endpoint
   b. Parse the fulltext response (ordered list of paragraphs)
   c. Write raw JSON to data/raw/zhuzi-yulei/chapter-NNN.json
3. Respect rate limits — add delay between requests (e.g., 2 seconds)
4. Log progress and handle ERR_REQUEST_LIMIT gracefully (retry with backoff)

Note: The ctext.org API returns paragraphs as an ordered array. Each paragraph
is a string of Classical Chinese text. Store as-is for processing.

Fallback: If API access is too restricted, use the Python `ctext` package
(`pip install ctext`) to fetch text, then convert output to JSON.

### Step 2.2: Create the Internet Archive acquisition script

Create scripts/acquire-archive.ts:

1. Download the full OCR text of De Ceremoniis from:
   https://archive.org/details/bub_gb_OFpFAAAAYAAJ
   Use the Internet Archive's download API: /download/{id}/{filename}
2. The Reiske edition contains Greek text with parallel Latin translation
3. Save raw text to data/raw/de-ceremoniis/full-text.txt

Alternative approach: Use the Internet Archive's BookReader API to fetch
page-by-page text if full download is unavailable.

### Step 2.3: Create the text processing script

Create scripts/process-texts.ts:

For Zhu Zi Yu Lei:
1. Read each chapter JSON from data/raw/zhuzi-yulei/
2. Split fulltext into paragraph objects: { index: N, text: "..." }
3. Output structured JSON to data/processed/zhuzi-yulei/chapter-NNN.json

For De Ceremoniis:
1. Read the raw OCR text
2. Identify chapter/section boundaries (Book I, Book II, numbered chapters)
3. Separate Greek text from Latin text (they appear on alternating pages
   or in parallel columns in the Reiske edition)
4. Clean OCR artifacts:
   - Fix common polytonic Greek misreadings
   - Remove page headers/footers
   - Normalize Unicode (NFC)
   - Fix ligature artifacts
5. Split each chapter into paragraph objects
6. Output to data/processed/de-ceremoniis/book-N-chapter-NNN.json

This step will likely require multiple iterations and manual verification.
Start with a few chapters and refine the parsing logic.

### Step 2.4: Create the database seed script

Create scripts/seed-db.ts:

1. Insert Language records: { code: "zh", name: "Classical Chinese" },
   { code: "grc", name: "Koine Greek" }, { code: "la", name: "Latin" }
2. Insert Author records:
   - { name: "Zhu Xi", nameOriginalScript: "朱熹", slug: "zhu-xi", era: "Song Dynasty (1130-1200)" }
   - { name: "Constantine VII", slug: "constantine-vii", era: "Byzantine (905-959)" }
3. Insert Text records with slugs and metadata
4. For each processed chapter JSON file:
   a. Insert Chapter record with sourceContent = paragraph array
   b. Create an initial Translation record (empty, awaiting AI translation)
5. Verify counts match expectations (140 chapters for ZZYL, etc.)

Run: `pnpm db:seed`

### Step 2.5: Commit processed texts and seed script

```bash
git add data/processed/ scripts/
git commit -m "Add source text acquisition and seeding scripts"
```

The data/raw/ directory remains gitignored (large, regenerable).
The data/processed/ directory is committed (cleaned, structured, canonical).

================================================================================
## PHASE 3: Core Reading Experience (Frontend)
================================================================================

### Step 3.1: Build the InterlinearViewer component

Create src/components/interlinear/InterlinearViewer.tsx:

Props:
- sourceContent: { paragraphs: { index: number; text: string }[] }
- translationContent: { paragraphs: { index: number; text: string }[] } | null
- sourceLanguage: string (for font selection)

Implementation:
- CSS Grid with two columns (or single column on mobile)
- Each row is a ParagraphPair component
- Left cell: source paragraph with appropriate font (CJK serif, polytonic Greek)
- Right cell: translation paragraph (or placeholder if not yet translated)
- Row height determined by tallest cell (natural grid behaviour)
- Responsive: on screens < 768px, stack columns vertically per paragraph

Create src/components/interlinear/ParagraphPair.tsx:
- Single row of the grid
- Handles empty translation gracefully (shows "Not yet translated" in muted text)
- Index number shown subtly in the gutter for reference

### Step 3.2: Build the TableOfContents component

Create src/components/navigation/TableOfContents.tsx:

Props:
- chapters: { chapterNumber: number; title: string; slug: string }[]
- currentChapter?: number
- textSlug: string, authorSlug: string, langCode: string

Implementation:
- Scrollable list of chapter links
- Current chapter highlighted
- Links to /[lang]/[author]/[text]/[chapter]

### Step 3.3: Build the CategoryBrowser component

Create src/components/navigation/CategoryBrowser.tsx:

- Top level: language cards (Classical Chinese, Koine Greek, Latin)
- Second level: alphabetical list of authors for selected language
- Third level: alphabetical list of texts for selected author
- Use Shadcn Tabs or accordion pattern

### Step 3.4: Create the chapter view page

Create src/app/(wiki)/[lang]/[author]/[text]/[chapter]/page.tsx:

- Server Component: fetches chapter data and current translation via tRPC caller
- Renders InterlinearViewer with source + translation
- Sidebar with TableOfContents for the parent text
- Navigation: prev/next chapter buttons
- "Edit" button (visible to logged-in users)
- "Endorse" button on the translation

### Step 3.5: Create the text index page

Create src/app/(wiki)/[lang]/[author]/[text]/page.tsx:

- Displays text metadata (title in original script + English, author, description)
- Source URL link
- TableOfContents listing all chapters
- Progress indicator: how many chapters have translations

### Step 3.6: Create the browse page

Create src/app/(wiki)/texts/page.tsx:

- CategoryBrowser component
- Flat list of all texts with language/author filters
- Search input (client-side filter initially)

### Step 3.7: Create the home page

Update src/app/page.tsx:

- Project description and purpose
- Featured texts (Zhu Zi Yu Lei and De Ceremoniis)
- "Browse all texts" link
- "Register to contribute" call-to-action

### Step 3.8: Create layout and navigation

Update src/app/layout.tsx:
- Header: site title, nav links, auth buttons
- Footer: project info

Create src/app/(wiki)/layout.tsx:
- Breadcrumb navigation

### Step 3.9: Add multilingual fonts

Configure fonts for:
- Noto Serif CJK (Chinese source text)
- Noto Serif with polytonic Greek support
- System serif for Latin and English

### Step 3.10: Write component tests

Tests for InterlinearViewer, TableOfContents, CategoryBrowser, ParagraphPair.

================================================================================
## PHASE 4: Editing & Version History
================================================================================

### Step 4.1: Build the TextEditor component

Create src/components/editor/TextEditor.tsx:

- Two-column layout: source (read-only) and editable textareas (right)
- One textarea per paragraph, preserving structure
- Paragraph count must match source
- Edit summary input
- Save button with loading state

### Step 4.2: Create the edit page

Create src/app/(wiki)/[lang]/[author]/[text]/[chapter]/edit/page.tsx:

- Protected route (redirect to login if unauthenticated)
- TextEditor with current chapter data
- On save: tRPC mutation → new TranslationVersion
- Redirect to chapter view on success

### Step 4.3: Implement translation mutations (backend)

In src/server/trpc/routers/translations.ts:

- createVersion: validates paragraph alignment, creates new version, updates head
- getHistory: returns all versions with author info and endorsement counts

### Step 4.4: Build EditHistory component

- Version list with author, timestamp, summary, endorsement count
- Click to view historical version

### Step 4.5: Build DiffViewer component

Install: `pnpm add diff @types/diff`
- Word-level diffs between two versions
- Additions in green, deletions in red

### Step 4.6: Create version history page

src/app/(wiki)/[lang]/[author]/[text]/[chapter]/history/page.tsx

### Step 4.7: Add edit/history buttons to chapter view

================================================================================
## PHASE 5: Endorsement System
================================================================================

### Step 5.1: Implement endorsement tRPC procedures

- toggle: add/remove endorsement, return new count
- getCount: endorsement count for a version
- getUserEndorsements: list of versions user has endorsed

### Step 5.2: Build EndorseButton component

- Shows count, filled/outlined state, optimistic updates
- Disabled for unauthenticated users

### Step 5.3: Integrate endorsements into chapter view

- EndorseButton on current translation
- "Community Preferred" label on most-endorsed version

### Step 5.4: User profile page with endorsement/edit history

================================================================================
## PHASE 6: AI Translation Generation
================================================================================

### Step 6.1: Set up Claude API client

`pnpm add @anthropic-ai/sdk`
Create src/server/translation/client.ts

### Step 6.2: Design translation prompts

Create src/server/translation/prompts.ts with language-specific system prompts.

### Step 6.3: Create batch translation script

scripts/translate-batch.ts:
- Queries untranslated chapters
- Sends to Claude API paragraph-by-paragraph
- Creates TranslationVersions with system user as author
- Rate limiting and resume capability

### Step 6.4: Mark AI translations in UI

Badge and banner encouraging human review.

### Step 6.5: Run initial translations

Start with 5-10 chapters to verify quality, then full batch.

================================================================================
## PHASE 7: Search, Polish & SEO
================================================================================

### Step 7.1: Full-text search with PostgreSQL GIN index
### Step 7.2: Search UI page
### Step 7.3: SEO metadata (generateMetadata, Open Graph, JSON-LD)
### Step 7.4: Responsive design testing and fixes
### Step 7.5: Loading skeletons and error boundaries
### Step 7.6: RSS feed for recent edits

================================================================================
## PHASE 8: Deployment
================================================================================

### Step 8.1: Production audit (env vars, tests, build)
### Step 8.2: Set up Neon production database, run migrations and seed
### Step 8.3: Deploy to Vercel, configure environment variables
### Step 8.4: Custom domain and SSL
### Step 8.5: Monitoring (Vercel Analytics, Sentry, UptimeRobot)
### Step 8.6: Post-deployment verification of all user flows

================================================================================
## SUBAGENT ASSIGNMENT (for parallel Claude Code execution)
================================================================================

If using multiple Claude Code instances simultaneously:

AGENT 1 — Infrastructure (Phase 1):
  Steps 1.1-1.11
  Deliverable: working project skeleton with auth, DB, tRPC connected

AGENT 2 — Text Acquisition (Phase 2):
  Steps 2.1-2.5 (can start once schema is defined in Step 1.5)
  Deliverable: data/processed/ populated, seed script working

AGENT 3 — Frontend Reading (Phase 3):
  Steps 3.1-3.10 (can start once tRPC is set up in Step 1.8)
  Deliverable: all reading pages functional

AGENT 4 — Editing & Versioning (Phase 4):
  Steps 4.1-4.7 (depends on Phase 3 pages existing)
  Deliverable: editing flow end-to-end

AGENT 5 — Endorsements + AI + Polish (Phases 5-7):
  Steps 5.1-7.6 (depends on Phase 4)
  Deliverable: endorsements, search, SEO, polish

DEPLOYMENT (Phase 8): after Phase 3 is complete (deploy early, iterate)

================================================================================
## ESTIMATED COSTS
================================================================================

Development phase (local):
- $0 — all tools are free/open-source
- Docker for local PostgreSQL
- Claude API for AI translations: ~$5-20 for initial batch

Hosting (production MVP):
- Vercel Hobby: $0/month
- Neon PostgreSQL free tier: $0/month
- Domain: ~$12/year
- Total: ~$1/month

Hosting (growing traffic):
- Vercel Pro: $20/month
- Neon Launch: $19/month
- Total: ~$40/month

AI Translation (one-time):
- Zhu Zi Yu Lei full: ~$0.50-2 (DeepSeek V3.2)
- De Ceremoniis full: ~$1-3 (DeepSeek V3.2)

================================================================================
## DEPLOYING TO VERCEL — Step-by-Step Guide
================================================================================

Prerequisites:
- Code pushed to GitHub (https://github.com/translorentz/translation-wiki.git)
- Neon database already configured and seeded
- A Vercel account (free tier is sufficient)

### Step D.1: Import the repository on Vercel

1. Go to https://vercel.com and sign in (or create account with GitHub)
2. Click "Add New..." → "Project"
3. Under "Import Git Repository", find `translorentz/translation-wiki`
   - If it doesn't appear, click "Adjust GitHub App Permissions" to grant
     Vercel access to the repository
4. Click "Import"

### Step D.2: Configure project settings

On the "Configure Project" screen:
- Framework Preset: should auto-detect "Next.js" (leave as-is)
- Root Directory: leave as "./" (default)
- Build Command: leave as `next build` (default)
- Output Directory: leave as default
- Install Command: leave as default (Vercel auto-detects pnpm from lockfile)
- Node.js Version: 20.x (default, compatible)

### Step D.3: Set environment variables

Before clicking "Deploy", expand "Environment Variables" and add:

┌──────────────────┬─────────────────────────────────────────────────────────┐
│ Name             │ Value                                                   │
├──────────────────┼─────────────────────────────────────────────────────────┤
│ DATABASE_URL     │ Your Neon connection string                             │
│                  │ (same value from .env.local, looks like:                │
│                  │  postgresql://user:pass@ep-xxx.region.aws.neon.tech/db   │
│                  │  ?sslmode=require)                                      │
├──────────────────┼─────────────────────────────────────────────────────────┤
│ AUTH_SECRET      │ Generate a random secret. Run in terminal:              │
│                  │   openssl rand -base64 32                               │
│                  │ Paste the output as the value.                          │
├──────────────────┼─────────────────────────────────────────────────────────┤
│ AUTH_URL         │ https://translation-wiki.vercel.app                     │
│                  │ (or your custom domain if you have one)                 │
│                  │ NOTE: Update this later if you add a custom domain.     │
├──────────────────┼─────────────────────────────────────────────────────────┤
│ DEEPSEEK_API_KEY │ Your DeepSeek API key from platform.deepseek.com       │
│                  │ (Only needed if you plan to run translations via the    │
│                  │  app in the future. Can be omitted for now.)            │
└──────────────────┴─────────────────────────────────────────────────────────┘

IMPORTANT: Set all variables for "Production", "Preview", and "Development"
environments (the checkboxes next to each variable).

### Step D.4: Deploy

Click "Deploy". Vercel will:
1. Clone the repository
2. Install dependencies (pnpm install)
3. Run `next build`
4. Deploy to a .vercel.app URL

First deploy typically completes in 1-2 minutes.

### Step D.5: Verify the deployment

Once deployed, Vercel gives you a URL like:
  https://translation-wiki.vercel.app

Check the following pages:
- Home page: https://translation-wiki.vercel.app/
- Chinese text: https://translation-wiki.vercel.app/zh/zhu-xi/zhuziyulei/chapter-1
- Greek text: https://translation-wiki.vercel.app/grc/constantine-vii/ceremonialis/chapter-1
- Login: https://translation-wiki.vercel.app/login
- Register: https://translation-wiki.vercel.app/register

If pages load with text data, the DATABASE_URL is working correctly.
If login/register work, AUTH_SECRET and AUTH_URL are configured correctly.

### Step D.6: Custom domain (optional)

1. In Vercel dashboard → your project → Settings → Domains
2. Click "Add Domain"
3. Enter your domain (e.g., translationwiki.org)
4. Vercel will provide DNS records to add:
   - For apex domain: A record → 76.76.21.21
   - For www subdomain: CNAME → cname.vercel-dns.com
5. Add these records at your domain registrar (Namecheap, Cloudflare, etc.)
6. Wait for DNS propagation (usually 5-30 minutes)
7. Vercel automatically provisions SSL (HTTPS)
8. UPDATE the AUTH_URL environment variable to https://yourdomain.com

### Step D.7: Automatic deployments

After initial setup, every `git push origin main` will trigger a new deployment.
Vercel also creates "Preview Deployments" for pull requests.

To redeploy manually: Vercel dashboard → Deployments → "Redeploy"

### Troubleshooting

Build fails with "DATABASE_URL is required":
  → Ensure DATABASE_URL is set in Vercel environment variables

Pages load but show no data:
  → Verify DATABASE_URL points to the Neon database with seeded data
  → The database must have schema applied (pnpm db:push was run earlier)

Auth doesn't work (redirect loops, 500 errors):
  → Check AUTH_SECRET is set (must not be empty)
  → Check AUTH_URL matches the actual deployment URL exactly
  → Ensure NEXTAUTH_URL is NOT set (use AUTH_URL instead for NextAuth v5)

500 errors on chapter pages:
  → Check Vercel Function Logs (dashboard → project → Logs tab)
  → Most likely a DATABASE_URL or connection issue

Custom domain shows "DNS not configured":
  → Wait 30 minutes for DNS propagation
  → Verify DNS records match what Vercel specified

================================================================================
## POST-DEPLOYMENT: Adding More Translations
================================================================================

To translate more chapters after deployment:

1. On your local machine, ensure .env.local has DATABASE_URL and DEEPSEEK_API_KEY
2. Run the batch translation script:

   # Translate specific chapters of Zhu Zi Yu Lei
   pnpm translate:batch -- --text zhuziyulei --start 4 --end 20

   # Translate specific chapters of De Ceremoniis
   pnpm translate:batch -- --text ceremonialis --start 2 --end 7

3. Translations are written directly to the Neon database
4. The deployed site will show new translations immediately (no redeployment needed)

Current translation status:
- Zhu Zi Yu Lei: Chapters 1-3 translated (of 140)
- De Ceremoniis: Chapters 1, 3 translated (of 7)

Translation API: DeepSeek V3.2 (deepseek-chat)
Cost estimate for remaining chapters: ~$1-3 total
